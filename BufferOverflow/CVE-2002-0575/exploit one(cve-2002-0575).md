## 说明
Published: 2003-04-02
Updated: 2003-03-21

Buffer overflow in OpenSSH before 2.9.9, and 3.x before 3.2.1, with Kerberos/AFS support and KerberosTgtPassing or AFSTokenPassing enabled, allows remote and local authenticated users to gain privileges.
在启用 Kerberos/AFS 支持且开启 KerberosTgtPassing 或 AFSTokenPassing 的情况下，OpenSSH 版本低于 2.9.9 和 3.x 版本低于 3.2.1 存在缓冲区溢出漏洞，允许远程或本地经过身份验证的用户提升权限。

Buffer overflow in OpenSSH allows privilege escalation for authenticated users before specific versions.
OpenSSH 中的缓冲区溢出允许在特定版本之前对经过身份验证的用户进行权限提升。

``` shell
source: https://www.securityfocus.com/bid/4560/info

A buffer overflow condition exists in the OpenSSH server. The condition is exploitable by attackers with valid user credentials in versions 2.9.9 and higher. Exploitation does not require valid user credentials in versions prior to 2.9.9.
OpenSSH 服务器中存在缓冲区溢出漏洞。在 2.9.9 及更高版本中，攻击者需拥有有效的用户凭证才能利用该漏洞。而在 2.9.9 之前的版本中，漏洞的利用不需要有效的用户凭证。

The vulnerability is related to the handling of Kerberos 4 TGT/AFS tokens passed by the client. An unbounded string copy operation may result in a stack overflow if the TGT/token data is malformed. 
该漏洞与客户端传递的 Kerberos 4 TGT/AFS 令牌的处理方式有关。如果 TGT/令牌数据格式错误，未受限制的字符串复制操作可能导致堆栈溢出。

https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/21402.tar
```

## Details
### 漏洞原理
```
- THIS IS A PROOF OF CONCEPT EXPOIT -
- 10/04/2002 -
- Marcell Fodor e-mail: m.fodor@mail.datanet.hu -


 code against OpenSSH 2.2.0 - 3.1.0 server

 
 effect:
	local root

 vulnerable services:
	-pass Kerberos IV TGT
	-pass AFS Token 

 bug details:
	radix.c
	GETSTRING macro in radix_to_creds function may cause buffer overflow.
	affected buffers:
	    creds->service
	    creds->instance
	    creds->realm
	    creds->pinst


漏洞详情：  
在 `radix.c` 文件中，`radix_to_creds` 函数中的 `GETSTRING` 宏可能会导致缓冲区溢出。
受影响的缓冲区包括：
- `creds->service`
- `creds->instance`
- `creds->realm`
- `creds->pinst`


 exploit code:
	-must have GNU MP Library installed  ftp://ftp.gnu.org/gnu/gmp
	-make
	-./tgt 127.0.0.1 <user> <password>

 egg:
	includes/egg.h
	    cp /bin/ash /tmp/ash
	    chmod 4755 /tmp/ash
```


openssh-3.1的radix.c文件中的radix_to_creds函数如下：
``` C
/*
该函数负责将经过编码（例如 Base64）的字符串缓冲区解码为 Kerberos 凭据（`CREDENTIALS` 结构体）。它从输入缓冲区中解析数据，并逐步填充 `CREDENTIALS` 结构体的各个字段。
*/

int
radix_to_creds(const char *buf, CREDENTIALS *creds)
{
    char *p;
    int len, tl;
    char version;
    char temp[2048];
   //解码输入缓冲区:
   //- 使用 `uudecode` 将编码后的 `buf` 转换为原始数据存储到临时缓冲区 `temp` 中。
   //- 若解码失败或长度非法（`len < 0`），直接返回 `0`。
    len = uudecode(buf, (u_char *)temp, sizeof(temp));
    if (len < 0)
        return 0;
        
    p = temp;
    /* check version and length! */
    //版本检查：
    //- 从 `temp` 中读取第一个字节作为版本号。
    //- 若长度不足 1，返回错误。
    if (len < 1)
        return 0;
    version = *p;
    p++;
    len--;
   
   //读取字符串字段：
   //- 使用宏 `GETSTRING` 依次读取 `creds` 的字符串字段：
   //- `service`（服务名称）
   //- `instance`（服务实例）
   //- `realm`（领域）
   //- `pname`（主体名称）
   //- `pinst`（主体实例）
    
    GETSTRING(creds->service, p, len);
    GETSTRING(creds->instance, p, len);
    GETSTRING(creds->realm, p, len);

    GETSTRING(creds->pname, p, len);
    GETSTRING(creds->pinst, p, len);
    /* Ignore possibly different realm. */
    while (*p && len)
        p++, len--;
    if (len == 0)
        return 0;
    p++, len--;

    /* Enough space for remaining fixed-length parts? */
    if (len < (4 + 4 + sizeof(creds->session) + 2 + 4))
        return 0;
  
    GETLONG(creds->issue_date, p);
    len -= 4;
    {
        u_int endTime;
        GETLONG(endTime, p);
        len -= 4;
        creds->lifetime = krb_time_to_life(creds->issue_date, endTime);
    }

    memcpy(&creds->session, p, sizeof(creds->session));
    p += sizeof(creds->session);
    len -= sizeof(creds->session);

    GETSHORT(creds->kvno, p);
    len -= 2;
    GETLONG(creds->ticket_st.length, p);
    len -= 4;

    tl = creds->ticket_st.length;
    if (tl < 0 || tl > len || tl > sizeof(creds->ticket_st.dat))
        return 0;

    memcpy(creds->ticket_st.dat, p, tl);
    p += tl;
    len -= tl;

    return 1;
}
```

`GETSTRING` 宏用于将输入缓冲区中的字符串复制到目标缓冲区（如 `creds->service`）。**由于没有对目标缓冲区大小进行严格的边界检查，可能导致缓冲区溢出。** 下面逐步分析该宏的逻辑以及潜在问题。

``` C
#define GETSTRING(s, p, p_l) {          \
    char *p_targ = (p) + p_l;   \   //定义输入缓冲区的结束位置
    char *s_c = (s);            \  //目标缓冲区的写入起点
    char *p_c = (p);            \  //输入缓冲区的读取起点
    while (*p_c && (p_c < p_targ)) {        \  //逐字节从输入缓冲区 `p_c` 读取数据，并写入到目标缓冲区 `s_c`。结束条件，要么读取到*p_c为空，要么到达输入缓冲区的尽头
    *s_c++ = *p_c++;            \
    }                       \
    if (p_c == p_targ) {            \ //`p_c` 达到结束位置 `p_targ`，则直接返回错误代码 `1`
    return 1;               \
    }                       \
    *s_c = *p_c++;              \ //- 追加一个字符到目标缓冲区。更新输入缓冲区的指针 `p` 和剩余长度 `p_l`。
    (p_l) = (p_l) - (p_c - (p));        \  
    (p) = p_c;                  \
}
```

下面解释漏洞原因：
1. 目标缓冲区大小未进行严格的检查：`GETSTRING` 假设目标缓冲区 `s` 有足够的空间存储从输入缓冲区复制的数据。但实际上`s` 的大小并未在 `GETSTRING` 宏中验证。如果输入数据（由 `p` 指针指定）长度超过目标缓冲区的大小，`while` 循环会导致写入超出 `s` 的边界，从而引发缓冲区溢出。
2. 输入数据由外部控制：输入缓冲区的数据来自外部用户输入（通过 `uudecode` 解码后）。攻击者可以构造恶意的输入数据，使目标缓冲区 `s` 被过长的数据填满并溢出，覆盖相邻内存区域。
