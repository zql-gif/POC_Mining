## 说明
Published: 2023-02-03
Updated: 2023-07-20

OpenSSH server (sshd) 9.1 introduced a double-free vulnerability during options.kex_algorithms handling. This is fixed in OpenSSH 9.2. The double free can be leveraged, by an unauthenticated remote attacker in the default configuration, to jump to any location in the sshd address space. One third-party report states "remote code execution is theoretically possible."
OpenSSH 服务器（sshd）9.1 在处理 `options.kex_algorithms` 时引入了一个双重释放（double-free）漏洞。该问题已在 OpenSSH 9.2 中修复。未经身份验证的远程攻击者可以在默认配置下利用该双重释放漏洞跳转到 sshd 地址空间中的任意位置。一份第三方报告指出，“理论上可能实现远程代码执行。”

## Details
### [double-free vulnerability in OpenSSH server 9.1](https://www.openwall.com/lists/oss-security/2023/02/02/2)

On February 2, 2023, OpenSSH version 9.2 was released: it fixes a
pre-authentication vulnerability (a double free) in the OpenSSH server
version 9.1 (only this specific version, which was released in October
2022). Affected users are urged to upgrade, as this vulnerability can be
triggered in the default configuration of the OpenSSH server (sshd).
2023年2月2日，OpenSSH 9.2 版本发布：该版本修复了 OpenSSH 服务器 9.1 版本中的一个预认证漏洞（双重释放）。该漏洞仅影响 9.1 版本，该版本于 2022 年10月发布。受影响的用户应尽快升级，因为此漏洞在 OpenSSH 服务器（sshd）的默认配置下即可被触发。

This double free was introduced in July 2022 by the following commit:
此双重释放漏洞是由以下提交引入的，时间为 2022 年7月：

[https://github.com/openssh/openssh-portable/commit/486c4dc3b83b4b67d663fb0fa62bc24138ec3946](https://github.com/openssh/openssh-portable/commit/486c4dc3b83b4b67d663fb0fa62bc24138ec3946)

and was reported to the OpenSSH Bugzilla in January 2023 by Mantas
Mikulenas:

[https://bugzilla.mindrot.org/show_bug.cgi?id=3522](https://bugzilla.mindrot.org/show_bug.cgi?id=3522)



The chunk of memory that is freed twice is "options.kex_algorithms"; it
is freed once via do_ssh2_kex(), which calls compat_kex_proposal():
被重复释放的内存块是“options.kex_algorithms”；
它在通过调用 `compat_kex_proposal()` 的 `do_ssh2_kex()` 函数中被释放了一次：

``` C
//file sshd.c
2103 do_ssh2_kex(ssh);
2104 do_authentication2(ssh);
```

``` C
//file sshd.c
2374 do_ssh2_kex(struct ssh *ssh)
....
2381         myproposal[PROPOSAL_KEX_ALGS] = prop_kex = compat_kex_proposal(ssh,
2382             options.kex_algorithms);
```

``` C
//file compat.c
191 compat_kex_proposal(struct ssh *ssh, char *p)
...
198         if ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)
199                 if ((p = match_filter_denylist(p,
...
202         if ((ssh->compat & SSH_OLD_DHGEX) != 0) {
203                 cp = p;
204                 if ((p = match_filter_denylist(p,
...
208                 free(cp);
```

``` C
//file compat.c
compat_kex_proposal(struct ssh *ssh, char *p)
{
    char *cp = NULL;
    if ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)
        return xstrdup(p);
    debug2_f("original KEX proposal: %s", p);
    if ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)
        if ((p = match_filter_denylist(p,
            "curve25519-sha256@libssh.org")) == NULL)
            fatal("match_filter_denylist failed");
    if ((ssh->compat & SSH_OLD_DHGEX) != 0) {
        cp = p;
        if ((p = match_filter_denylist(p,
            "diffie-hellman-group-exchange-sha256,"
            "diffie-hellman-group-exchange-sha1")) == NULL)
            fatal("match_filter_denylist failed");
        free(cp);
    }
    debug2_f("compat KEX proposal: %s", p);
    if (*p == '\0')
        fatal("No supported key exchange algorithms found");
    return p;
}
```

- if at line 198 the "SSH_BUG_CURVE25519PAD" compatibility bit is *not*
  set,
- and if at line 202 the "SSH_OLD_DHGEX" compatibility bit *is* set,
- then at line 203 "cp" becomes equal to "p", which is still equal to
  "options.kex_algorithms",
- and at line 208 "cp" is freed, i.e. "options.kex_algorithms" is freed
  and becomes a dangling pointer.

- 如果在第 198 行中，未设置 "SSH_BUG_CURVE25519PAD" 兼容性位，即不会进入198行下面的if判断分支；
- 并且在第 202 行中，已设置 "SSH_OLD_DHGEX" 兼容性位，即进入202行的if判断分支
- **那么在第 203 行，"cp" 将等于 "p"，而 "p" 仍然等于 "options.kex_algorithms"，**
- **在第 208 行，"cp" 被释放，即 "options.kex_algorithms" 被释放并变为悬空指针**

(Note: the "SSH_BUG_CURVE25519PAD" and "SSH_OLD_DHGEX" compatibility
bits depend only on the client version, not on the server configuration;
for example, the bug report mentioned earlier uses "PuTTY_Release_0.64",
and we will use "FuTTY" for the ssh client version later in this post.)
（注意："SSH_BUG_CURVE25519PAD" 和 "SSH_OLD_DHGEX" 兼容性位仅取决于客户端版本，而不依赖于服务器配置；例如，前面提到的漏洞报告中使用了 "PuTTY_Release_0.64"，而我们将在本文后续部分中使用 "FuTTY" 作为 SSH 客户端版本。）

"options.kex_algorithms" is then freed a second time via
do_authentication2(), which calls input_userauth_request(), which calls
mm_getpwnamallow(), which calls copy_set_server_options(), which calls
assemble_algorithms(), which calls kex_assemble_names() with "listp"
equal to "&options.kex_algorithms", which therefore double-frees
"options.kex_algorithms" at line 315:
**“options.kex_algorithms” 随后在以下过程中被第二次释放：通过 `do_authentication2()` 调用 `input_userauth_request()`，然后调用 `getpwnamallow()`（这里和官方给出的有出入，官方给的为mm_getpwnamallow()，修改成getpwnamallow()了），再调用 `copy_set_server_options()`，接着调用 `assemble_algorithms()`，最终调用 `kex_assemble_names()`，此时参数 `listp` 等于 `&options.kex_algorithms`，因此在第 315 行再次释放了 “options.kex_algorithms”，导致双重释放：**

``` C
//sshd.c:do_authentication2
2103 do_ssh2_kex(ssh);
2104 do_authentication2(ssh);  //s1
```

``` C
//auth2.c:do_authentication2->input_userauth_request
void
do_authentication2(struct ssh *ssh)
{
    Authctxt *authctxt = ssh->authctxt;
    ssh_dispatch_init(ssh, &dispatch_protocol_error);
    ssh_dispatch_set(ssh, SSH2_MSG_SERVICE_REQUEST, &input_service_request); //s2
    ssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt->success);
    ssh->authctxt = NULL;
}


//auth2.c:input_userauth_request->getpwnamallow
/*ARGSUSED*/
static int
input_userauth_request(int type, u_int32_t seq, struct ssh *ssh)
{
    Authctxt *authctxt = ssh->authctxt;
    Authmethod *m = NULL;
    char *user = NULL, *service = NULL, *method = NULL, *style = NULL;
    int r, authenticated = 0;
    double tstart = monotime_double();
    if (authctxt == NULL)
        fatal("input_userauth_request: no authctxt");
    if ((r = sshpkt_get_cstring(ssh, &user, NULL)) != 0 ||
        (r = sshpkt_get_cstring(ssh, &service, NULL)) != 0 ||
        (r = sshpkt_get_cstring(ssh, &method, NULL)) != 0)
        goto out;
    debug("userauth-request for user %s service %s method %s", user, service, method);
    debug("attempt %d failures %d", authctxt->attempt, authctxt->failures);
    if ((style = strchr(user, ':')) != NULL)
        *style++ = 0;
    if (authctxt->attempt >= 1024)
        auth_maxtries_exceeded(ssh);
    if (authctxt->attempt++ == 0) {
        /* setup auth context */
        authctxt->pw = PRIVSEP(getpwnamallow(ssh, user));        //s3
        if (authctxt->pw && strcmp(service, "ssh-connection")==0) {
            authctxt->valid = 1;
            debug2_f("setting up authctxt for %s", user);
        } else {
        
    ....
}
```


调用copy_set_server_options的是`getpwnamallow

``` C
//auth.c:getpwnamallow -> parse_server_match_config
struct passwd *
getpwnamallow(struct ssh *ssh, const char *user)
{
    extern login_cap_t *lc;
    auth_session_t *as;
    struct passwd *pw;
    struct connection_info *ci;
    u_int i;

    ci = get_connection_info(ssh, 1, options.use_dns);
    ci->user = user;
    parse_server_match_config(&options, &includes, ci);  //s4
    log_change_level(options.log_level);
    log_verbose_reset();
    for (i = 0; i < options.num_log_verbose; i++)
        log_verbose_add(options.log_verbose[i]);
    process_permitopen(ssh, &options);
    ....
 }
```

``` C
//auth2.c:parse_server_match_config -> copy_set_server_options
void
parse_server_match_config(ServerOptions *options,
   struct include_list *includes, struct connection_info *connectinfo)
{
    ServerOptions mo;
    initialize_server_options(&mo);
    parse_server_config(&mo, "reprocess config", cfg, includes,
        connectinfo, 0);
    copy_set_server_options(options, &mo, 0); //s5
}
```


``` C
//servconf.c: copy_set_server_options->assemble_algorithms
void
copy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)
{
    .....
    
    /* See comment in servconf.h */
    COPY_MATCH_STRING_OPTS();

    /* Arguments that accept '+...' need to be expanded */
     assemble_algorithms(dst);  //约2597行,s
    /*
     * The only things that should be below this point are string options
     * which are only used after authentication.
     */
    if (preauth)
        return;
    ....
}
```


``` C
//servconf.c:assemble_algorithms->kex_assemble_names
static void

assemble_algorithms(ServerOptions *o)

{
....

#define ASSEMBLE(what, defaults, all) \
    do { \
        if ((r = kex_assemble_names(&o->what, defaults, all)) != 0) \ //
            fatal_fr(r, "%s", #what); \
    } while (0)
    ASSEMBLE(ciphers, def_cipher, all_cipher);
    ASSEMBLE(macs, def_mac, all_mac);
    ASSEMBLE(kex_algorithms, def_kex, all_kex);
    ASSEMBLE(hostkeyalgorithms, def_key, all_key);
    ASSEMBLE(hostbased_accepted_algos, def_key, all_key);
    ASSEMBLE(pubkey_accepted_algos, def_key, all_key);
    ASSEMBLE(ca_sign_algorithms, def_sig, all_sig);
#undef ASSEMBLE
  
  .....
}
```

``` C
//kex.c:kex_assemble_names
 225 kex_assemble_names(char **listp, const char *def, const char *all)
 ...
 240         list = *listp;
 ...
 315         free(list);
```




To reproduce this vulnerability, we installed a Debian testing
(bookworm, which ships OpenSSH 9.1p1 at the time of writing this post)
and we simply modified the banner of the ssh client to pretend that it
is a "FuTTY" client (to force the "SSH_OLD_DHGEX" compatibility bit in
sshd):
为了重现此漏洞，我们安装了 Debian 测试版（Bookworm，在撰写本文时其附带 OpenSSH 9.1p1），然后我们简单地修改了 SSH 客户端的标识，使其伪装为“FuTTY”客户端（以强制在 sshd 中启用 “SSH_OLD_DHGEX” 兼容性位）：

```
$ cp -i /usr/bin/ssh ./ssh

$ sed -i s/OpenSSH_9.1p1/FuTTYSH_9.1p1/g ./ssh

$ ./ssh -v 127.0.0.1
...
debug1: Local version string SSH-2.0-FuTTYSH_9.1p1 Debian-2
debug1: Remote protocol version 2.0, remote software version OpenSSH_9.1p1 Debian-2
...
debug1: SSH2_MSG_SERVICE_ACCEPT received
Connection closed by 127.0.0.1 port 22
```


This connection immediately triggered a double free in the unprivileged
sshd process, as shown by the "Connection closed by 127.0.0.1 port 22"
message above and by the strace output below:

```
writev(2, [{iov_base="free(): double free detected in tcache 2", iov_len=40}, {iov_base="\n", iov_len=1}], 2) = 20
--- SIGSYS {si_signo=SIGSYS, si_code=SYS_SECCOMP, si_call_addr=0x7f093649e1f5, si_syscall=__NR_writev, si_arch=AUDIT_ARCH_X86_64} ---
write(8, "\0\0\0g\0\0\0\1\0\0\0\0\0\0\0[ssh_sandbox_violation: unexpected system call (arch:0xc000003e,syscall:20 @ 0x7f093649e1f5)", 107) = 107
exit_group(1)                           = ?
+++ exited with 1 +++
```

Exploiting this vulnerability will not be easy: modern memory allocators
provide protections against double frees, and the impacted sshd process
is unprivileged and heavily sandboxed.

Once again we thank OpenSSH's developers for their outstanding work and
for their implementation of these defense-in-depth mechanisms (privilege
separation, sandboxing) that make it so much harder to exploit such a
vulnerability.



### Vulnerability In-Depth Details(openssh9.1)

We started by examining the fix commit stating that `compat_kex_proposal()` is responsible for the double-free. When the connection compatibility option `SSH_OLD_DHGEX` is true on [1], the second argument `p` is assigned to `cp` on [2] and later freed on [3].

```
/* Always returns pointer to allocated memory, caller must free. */
char *
compat_kex_proposal(struct ssh *ssh, char *p)
{
    char *cp = NULL;

    if ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)
        return xstrdup(p);
    debug2_f("original KEX proposal: %s", p);
    if ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)
        if ((p = match_filter_denylist(p,
            "curve25519-sha256@libssh.org")) == NULL)
            fatal("match_filter_denylist failed");
    if ((ssh->compat & SSH_OLD_DHGEX) != 0) {               [1]
        cp = p;                                             [2]
        if ((p = match_filter_denylist(p,
            "diffie-hellman-group-exchange-sha256,"
            "diffie-hellman-group-exchange-sha1")) == NULL)
            fatal("match_filter_denylist failed");
        free(cp);                                           [3]
    }
    debug2_f("compat KEX proposal: %s", p);
    if (*p == '\0')
        fatal("No supported key exchange algorithms found");
    return p;
}
```

The call to `compat_kex_proposal()` is inside the `do_ssh2_kex()` function:

```
    myproposal[PROPOSAL_KEX_ALGS] = prop_kex = compat_kex_proposal(ssh,
        options.kex_algorithms);
```

The freed `cp=p` from `compat_kex_proposal()` refers to the `options.kex_algorithms` argument.

Searching for `kex_algorithms` in the source code, we encountered the `assemble_algorithms` from the crash in the Bugzilla report:

```
ASSEMBLE(kex_algorithms, def_kex, all_kex);
```

`ASSEMBLE` is a macro for calling the `kex_assemble_names()` function:

```
#define ASSEMBLE(what, defaults, all) \
    do { \
        if ((r = kex_assemble_names(&o->what, defaults, all)) != 0) \
            fatal_fr(r, "%s", #what); \
    } while (0)
```

The `kex_assemble_names()` function is called with the address of `o->kex_algorithms` as its first argument (which is `listp`). This is where the second free occurs.

```
int
kex_assemble_names(char **listp, const char *def, const char *all)
```

Due to the `options.kex_algorithms` handle being freed and becoming a dangling pointer, it’s once again freed causing a double-free.

But where is the `SSH_OLD_DHGEX` option set?

Inside the `compat_banner()` function, which determines bug flags from the SSH protocol banner. A struct named `check[]` lists all the SSH client IDs and their flags. The following snippet shows the Client IDs that are assigned the `SSH_OLD_DHGEX` option. We can also see that WinSCP might also be able to trigger this behavior.

```
        { "PuTTY_Local:*,"  /* dev versions < Sep 2014 */ "PuTTY-Release-0.5*," /* 0.50-0.57, DH-GEX in >=0.52 */
          "PuTTY_Release_0.5*," /* 0.58-0.59 */
          "PuTTY_Release_0.60*,"
          "PuTTY_Release_0.61*,"
          "PuTTY_Release_0.62*,"
          "PuTTY_Release_0.63*,"
          "PuTTY_Release_0.64*",
                    SSH_OLD_DHGEX },
        { "FuTTY*",     SSH_OLD_DHGEX }, /* Putty Fork */
        { "WinSCP_release_4*,"
          "WinSCP_release_5.0*,"
          "WinSCP_release_5.1,"
          "WinSCP_release_5.1.*,"
          "WinSCP_release_5.5,"
          "WinSCP_release_5.5.*,"
          "WinSCP_release_5.6,"
          "WinSCP_release_5.6.*,"
          "WinSCP_release_5.7,"
          "WinSCP_release_5.7.1,"
          "WinSCP_release_5.7.2,"
          "WinSCP_release_5.7.3,"
          "WinSCP_release_5.7.4",
                    SSH_OLD_DHGEX },
```


















The first time it was freed was via do_ssh2_kex(), which calls compat_kex_proposal(). In the case where the compatibility bit “SSH_BUG_CURVE25519PAD” is not set and the compatibility bit “SSH_OLD_DHGEX” is set, “options.kex_algorithms” becomes a dangling pointer after being freed. This results in the memory being freed a second time via kex_assemble_names() with “listp” equal to “&options.kex_algorithms”. 
第一次释放发生在 `do_ssh2_kex()` 函数中，该函数调用了 `compat_kex_proposal()`。
在未设置兼容性位“`SSH_BUG_CURVE25519PAD`”且设置了兼容性位“`SSH_OLD_DHGEX`”的情况下，
“`options.kex_algorithms`”在被释放后变成了悬空指针。
这导致该内存在`kex_assemble_names()` 函数中被再次释放，其中“`listp`”的值为“`&options.kex_algorithms`”。


### 其他简单解释(忽略)

The exposure occurs in the chunk of memory freed twice, the “options.kex_algorithms”. The first time it was freed was via do_ssh2_kex(), which calls compat_kex_proposal(). In the case where the compatibility bit “SSH_BUG_CURVE25519PAD” is not set and the compatibility bit “SSH_OLD_DHGEX” is set, “options.kex_algorithms” becomes a dangling pointer after being freed. This results in the memory being freed a second time via kex_assemble_names() with “listp” equal to “&options.kex_algorithms”. 
漏洞的暴露发生在被多次释放的内存块“`options.kex_algorithms`”上。
第一次释放发生在 `do_ssh2_kex()` 函数中，该函数调用了 `compat_kex_proposal()`。
在未设置兼容性位“`SSH_BUG_CURVE25519PAD`”且设置了兼容性位“`SSH_OLD_DHGEX`”的情况下，
“`options.kex_algorithms`”在被释放后变成了悬空指针。
这导致该内存在`kex_assemble_names()` 函数中被再次释放，其中“`listp`”的值为“`&options.kex_algorithms`”。


In order to demonstrate a vulnerability, Qualys Threat Research Unit (TRU) set up a testing environment utilizing Debian (bookworm) with OpenSSH 9.1p1 installed. We then modified the banner of the ssh client to present as a “FuTTY” client, which resulted in forcing the “SSH_OLD_DHGEX” compatibility bit in the ssh daemon (sshd). The steps taken to achieve this are outlined below:
为了演示该漏洞，Qualys 威胁研究部门 (TRU) 建立了一个测试环境，该环境使用了安装有 OpenSSH 9.1p1 的 Debian (bookworm) 系统。然后，我们修改了 SSH 客户端的横幅信息，使其显示为“FuTTY”客户端，从而迫使 SSH 守护进程 (sshd) 启用了“`SSH_OLD_DHGEX`”兼容性位。实现这一目标的步骤如下所述：

``` shell
$ cp -i /usr/bin/ssh ./ssh  
$ sed -i s/OpenSSH_9.1p1/FuTTYSH_9.1p1/g ./ssh  
$ ./ssh -v 127.0.0.1
```

This action resulted in a double free in the unprivileged sshd process, as indicated by the error message and the strace output:
此操作导致了非特权 sshd 进程中的双重释放，如错误消息和 strace 输出所示：

``` shell
writev(2, [{iov_base="free(): double free detected in tcache 2", iov_len=40}, {iov_base="\n", iov_len=1}], 2) = 20  

--- SIGSYS {si_signo=SIGSYS, si_code=SYS_SECCOMP, si_call_addr=0x7f093649e1f5, si_syscall=__NR_writev, si_arch=AUDIT_ARCH_X86_64} ---  

write(8, "\0\0\0g\0\0\0\1\0\0\0\0\0\0\0[ssh_sandbox_violation: unexpected system call (arch:0xc000003e,syscall:20 @ 0x7f093649e1f5)", 107) = 107  

exit_group(1)                           = ?  

+++ exited with 1 +++
```

While the double-free vulnerability in OpenSSH version 9.1 may raise concerns, it is essential to note that exploiting this issue is no simple task. This is due to the protective measures put in place by modern memory allocators and the robust privilege separation and sandboxing implemented in the impacted sshd process.  
虽然 OpenSSH 9.1 版本中的双重释放漏洞可能引起担忧，但需要注意的是，利用此漏洞并非易事。这主要归功于现代内存分配器的保护措施以及受影响的 sshd 进程中实施的强大权限隔离和沙箱机制。

Affected users are highly encouraged to upgrade to OpenSSH 9.2 to prevent potential security risks. The OpenSSH project has been instrumental in ensuring secure remote access to systems, and the recent release of 9.2 is a testament to their commitment to the community’s security.
强烈建议受影响的用户升级到 OpenSSH 9.2，以避免潜在的安全风险。OpenSSH 项目在确保系统安全远程访问方面发挥了重要作用，而最近发布的 9.2 版本进一步证明了其对社区安全的承诺。

