## 说明
Published: 2021-03-05
Updated: 2021-07-20

ssh-agent in OpenSSH before 8.5 has a double free that may be relevant in a few less-common scenarios, such as unconstrained agent-socket access on a legacy operating system, or the forwarding of an agent to an attacker-controlled host.
在 OpenSSH 8.5 之前的版本中，`ssh-agent` 存在一个双重释放漏洞，这可能与某些较少见的场景相关，例如在旧版操作系统上对代理套接字（agent-socket）的不受限制访问，或将代理转发到由攻击者控制的主机。
## Details(openssh8.2)

1. **`ext_name` 的分配和释放：**
    - `ext_name` 是通过 `sshbuf_get_cstring()` 分配的内存。在 `SSH_AGENT_CONSTRAIN_EXTENSION` 分支中，获取并赋值 `ext_name` 后，调用了 `free(ext_name)` 释放了内存。
    - 之后在 `err` 标签中（在 `goto err` 跳转时），再次调用了 `free(ext_name)`。

``` C
//ssh-agent.c:process_add_identity函数
static void
process_add_identity(SocketEntry *e)
{
    Identity *id;
    int success = 0, confirm = 0;
    u_int seconds, maxsign;
    char *fp, *comment = NULL, *ext_name = NULL, *sk_provider = NULL;
    char canonical_provider[PATH_MAX];
    time_t death = 0;
    struct sshkey *k = NULL;
    u_char ctype;
    int r = SSH_ERR_INTERNAL_ERROR;

    if ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||
        k == NULL ||
        (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {
        error("%s: decode private key: %s", __func__, ssh_err(r));
        goto err;
    }
    while (sshbuf_len(e->request)) {
        if ((r = sshbuf_get_u8(e->request, &ctype)) != 0) {
            error("%s: buffer error: %s", __func__, ssh_err(r));
            goto err;
        }
        switch (ctype) {
        case SSH_AGENT_CONSTRAIN_LIFETIME:
            if ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {
                error("%s: bad lifetime constraint: %s",
                    __func__, ssh_err(r));
                goto err;
            }
            death = monotime() + seconds;
            break;
        case SSH_AGENT_CONSTRAIN_CONFIRM:
            confirm = 1;
            break;
        case SSH_AGENT_CONSTRAIN_MAXSIGN:
            if ((r = sshbuf_get_u32(e->request, &maxsign)) != 0) {
                error("%s: bad maxsign constraint: %s",
                    __func__, ssh_err(r));
                goto err;
            }
            if ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {
                error("%s: cannot enable maxsign: %s",
                    __func__, ssh_err(r));
                goto err;
            }
            break;
        case SSH_AGENT_CONSTRAIN_EXTENSION:
            if ((r = sshbuf_get_cstring(e->request,
                &ext_name, NULL)) != 0) {
                error("%s: cannot parse extension: %s",
                    __func__, ssh_err(r));
                goto err;
            }
            debug("%s: constraint ext %s", __func__, ext_name);
            if (strcmp(ext_name, "sk-provider@openssh.com") == 0) {
                if (sk_provider != NULL) {
                    error("%s already set", ext_name);
                    goto err;
                }
                if ((r = sshbuf_get_cstring(e->request,
                    &sk_provider, NULL)) != 0) {
                    error("%s: cannot parse %s: %s",
                        __func__, ext_name, ssh_err(r));
                    goto err;
                }
            } else {
                error("%s: unsupported constraint \"%s\"",
                    __func__, ext_name);
                goto err;
            }
            free(ext_name);      //free 1
            break;
        default:
            error("%s: Unknown constraint %d", __func__, ctype);
 err:
            free(sk_provider);
            free(ext_name);   //free 2
            sshbuf_reset(e->request);
            free(comment);
            sshkey_free(k);
            goto send;
        }
    }

   ......
   
   if ((r = sshkey_shield_private(k)) != 0) {
       error("%s: shield private key: %s", __func__, ssh_err(r));
        goto err;  //goto err;去执行第二次free
    }
    ......
}
```



