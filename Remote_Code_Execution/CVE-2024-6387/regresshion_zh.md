一个比较清晰的解说： [[漏洞分析] CVE-2024-6387 OpenSSH核弹核的并不是很弹-CSDN博客](https://blog.csdn.net/Breeze_CAT/article/details/140126620)

[CVE-2024-6387 分析-CSDN博客](https://blog.csdn.net/qq_54218833/article/details/140146142)


**Qualys Security Advisory**

regreSSHion: RCE in OpenSSH's server, on glibc-based Linux systems
(CVE-2024-6387)
回归漏洞：OpenSSH 服务器中的远程代码执行漏洞，影响基于 glibc 的 Linux 系统
(CVE-2024-6387)

# Contents
[Summary](#Summary)

[SSH-2.0-OpenSSH_3.4p1 Debian 1:3.4p1-1.woody.3 (Debian 3.0r6, from 2005)](#ssh-20-openssh_34p1-debian-134p1-1woody3-debian-30r6-from-2005)
- [Theory](#theory)
- [Practice](#Practice)
- [Timing](#Timing)

[ SSH-2.0-OpenSSH_4.2p1 Debian-7ubuntu3 (Ubuntu 6.06.1, from 2006)](#ssh-20-openssh_42p1-debian-7ubuntu3-ubuntu-6061-from-2006)
- [Theory, take one](#theory-take-one)
- [Theory, take two](#theory-take-two)
- [Practice](#practice-1)
- [Timing](#timing-1)

[SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u2 (Debian 12.5.0, from 2024)](#ssh-20-openssh_92p1-debian-2deb12u2-debian-1250-from-2024)
- [Theory](#theory-1)
- [Practice](#practice-2)
- [Timing](#timing-2)

[Towards an amd64 exploit](#towards-an-amd64-exploit)

[Patches and mitigation](#patches-and-mitigation)

[Acknowledgments](#acknowledgments)

[Timeline](#timeline)

# Summary

> 一切只需要信念的一跃  
> -- The Interrupters，《Leap of Faith》

Preliminary note: OpenSSH is one of the most secure software in the
world; this vulnerability is one slip-up in an otherwise near-flawless
implementation. Its defense-in-depth design and code are a model and an
inspiration, and we thank OpenSSH's developers for their exemplary work.
**前言：** OpenSSH 是世界上最安全的软件之一；这次漏洞是一个意外的失误，发生在一个几乎完美的实现中。它的深度防御设计和代码是一个典范和灵感来源，我们感谢 OpenSSH 的开发人员做出的卓越贡献。

We discovered a vulnerability (a signal handler race condition) in
OpenSSH's server (sshd): if a client does not authenticate within
LoginGraceTime seconds (120 by default, 600 in old OpenSSH versions),
then sshd's SIGALRM handler is called asynchronously, but this signal
handler calls various functions that are not async-signal-safe (for
example, syslog()). This race condition affects sshd in its default
configuration.
我们发现了一个漏洞（信号处理程序条件竞争），该漏洞影响 OpenSSH 服务器（sshd）：如果客户端在 `LoginGraceTime` 秒内没有完成认证（默认值为 120 秒，旧版本 OpenSSH 为 600 秒），则 sshd 的 `SIGALRM` 处理程序会异步调用，但该信号处理程序调用了一些不是异步信号安全的函数（例如，`syslog()`）。这个竞争条件影响 sshd 的默认配置。

On investigation, we realized that this vulnerability is in fact a
regression of CVE-2006-5051 ("Signal handler race condition in OpenSSH
before 4.4 allows remote attackers to cause a denial of service (crash),
and possibly execute arbitrary code"), which was reported in 2006 by
Mark Dowd.
在调查过程中，我们意识到这个漏洞实际上是 CVE-2006-5051 的回归（"OpenSSH 4.4 之前的版本中，信号处理程序的条件竞争允许远程攻击者造成拒绝服务（崩溃），并可能执行任意代码"），该漏洞在 2006 年由 Mark Dowd 报告。

This regression was introduced in October 2020 (OpenSSH 8.5p1) by commit
752250c ("revised log infrastructure for OpenSSH"), which accidentally
removed an "#ifdef DO_LOG_SAFE_IN_SIGHAND" from sigdie(), a function
that is directly called by sshd's SIGALRM handler. In other words:
此回归是在 2020 年 10 月（OpenSSH 8.5p1）通过提交 752250c ("重新修订 OpenSSH 的日志基础设施") 引入的，该提交意外删除了 sigdie() 函数中的 "#ifdef DO_LOG_SAFE_IN_SIGHAND"。sigdie() 是由 sshd 的 `SIGALRM` 处理程序直接调用的函数。换句话说：

- OpenSSH < 4.4p1 is vulnerable to this signal handler race condition,
  if not backport-patched against CVE-2006-5051, or not patched against
  CVE-2008-4109, which was an incorrect fix for CVE-2006-5051;
- **OpenSSH < 4.4p1** 易受此信号处理程序竞争条件的影响，如果没有对 CVE-2006-5051 进行回溯修补，或者没有修补 CVE-2008-4109（这是对 CVE-2006-5051 的不正确修复）；

- 4.4p1 <= OpenSSH < 8.5p1 is not vulnerable to this signal handler race
  condition (because the "#ifdef DO_LOG_SAFE_IN_SIGHAND" that was added
  to sigdie() by the patch for CVE-2006-5051 transformed this unsafe
  function into a safe _exit(1) call);
- **4.4p1 <= OpenSSH < 8.5p1** 不容易受到此信号处理程序条件竞争的影响（因为补丁 CVE-2006-5051 中添加的 `#ifdef DO_LOG_SAFE_IN_SIGHAND` 将 `sigdie()` 中的不安全函数转变为安全的 `_exit(1)` 调用）。

- 8.5p1 <= OpenSSH < 9.8p1 is vulnerable again to this signal handler
  race condition (because the "#ifdef DO_LOG_SAFE_IN_SIGHAND" was
  accidentally removed from sigdie()).
- **8.5p1 <= OpenSSH < 9.8p1** 再次易受此信号处理程序竞争条件的影响（因为从 sigdie() 中意外删除了 "#ifdef DO_LOG_SAFE_IN_SIGHAND"）。


This vulnerability is exploitable remotely on glibc-based Linux systems,
where syslog() itself calls async-signal-unsafe functions (for example,
malloc() and free()): an unauthenticated remote code execution as root,
because it affects sshd's privileged code, which is not sandboxed and
runs with full privileges. We have not investigated any other libc or
operating system; but OpenBSD is notably not vulnerable, because its
SIGALRM handler calls syslog_r(), an async-signal-safer version of
syslog() that was invented by OpenBSD in 2001.
这个漏洞在基于 glibc 的 Linux 系统中是可远程利用的，因为 `syslog()` 本身调用了非异步信号安全的函数（例如，`malloc()` 和 `free()`）：远程未认证的 root 代码执行，因为它影响了 sshd 的特权代码，而该代码没有沙箱保护并且以完整权限运行。我们没有研究其他 libc 或操作系统，但 OpenBSD 显然不受影响，因为其 `SIGALRM` 处理程序调用了 `syslog_r()`，这是 OpenBSD 在 2001 年发明的异步信号安全版本的 `syslog()`。

To exploit this vulnerability remotely (to the best of our knowledge,
CVE-2006-5051 has never been successfully exploited before), we drew
inspiration from a visionary paper, "Delivering Signals for Fun and
Profit", which was published in 2001 by Michal Zalewski:
[https://lcamtuf.coredump.cx/signals.txt](https://lcamtuf.coredump.cx/signals.txt)
为了远程利用这个漏洞（据我们所知，CVE-2006-5051 之前从未成功利用过），我们从一篇具有远见的论文《Delivering Signals for Fun and Profit》中获得灵感，该论文由 Michal Zalewski 于 2001 年发布：
https://lcamtuf.coredump.cx/signals.txt


Nevertheless, we immediately faced three major problems:
- From a theoretical point of view, we must find a useful code path
  that, if interrupted at the right time by SIGALRM, leaves sshd in an
  inconsistent state, and we must then exploit this inconsistent state
  inside the SIGALRM handler.
- **理论方面：** 我们必须找到一条有用的代码路径，如果在正确的时间被 `SIGALRM` 中断，会使 sshd 处于不一致的状态，然后我们必须在 `SIGALRM` 处理程序内利用这个不一致的状态。

- From a practical point of view, we must find a way to reach this
  useful code path in sshd, and maximize our chances of interrupting it
  at the right time.
- **实践方面：** 我们必须找到一种方法来访问 sshd 中的这条有用的代码路径，并最大化我们在正确时间中断它的机会。

- From a timing point of view, we must find a way to further increase
  our chances of interrupting this useful code path at the right time,
  remotely.
- **时序方面：** 我们必须找到一种方法进一步提高我们在正确时间远程中断这条有用的代码路径的机会。

To focus on these three problems without having to immediately fight
against all the modern operating system protections (in particular, ASLR
and NX), we decided to exploit old OpenSSH versions first, on i386, and
then, based on this experience, recent versions:
为了专注于这三个问题而不立即与所有现代操作系统的保护机制（尤其是 ASLR 和 NX）对抗，我们决定首先在 i386 上利用旧版 OpenSSH，然后根据经验再研究近期版本：

- First, "SSH-2.0-OpenSSH_3.4p1 Debian 1:3.4p1-1.woody.3", from
  "debian-30r6-dvd-i386-binary-1_NONUS.iso": this is the first Debian
  version that has privilege separation enabled by default and that is
  patched against all the critical vulnerabilities of that era (in
  particular, CVE-2003-0693 and CVE-2002-0640).

  To remotely exploit this version, we interrupt a call to free() with
  SIGALRM (inside sshd's public-key parsing code), leave the heap in an
  inconsistent state, and exploit this inconsistent state during another
  call to free(), inside the SIGALRM handler.

  In our experiments, it takes ~10,000 tries on average to win this race
  condition; i.e., with 10 connections (MaxStartups) accepted per 600
  seconds (LoginGraceTime), it takes ~1 week on average to obtain a
  remote root shell.
-  **首先，"SSH-2.0-OpenSSH_3.4p1 Debian 1:3.4p1-1.woody.3"，来自 "debian-30r6-dvd-i386- binary-1_NONUS.iso"：** 这是第一个默认启用特权分离的 Debian 版本，且已修补该时期的所有 关键漏洞（特别是 CVE-2003-0693 和 CVE-2002-0640）。

   要远程利用这个版本，我们通过 `SIGALRM` 中断对 `free()` 的调用（在 sshd 的公钥解析代码中），将堆留在不一致的状态，然后在另一次调用 `free()` 时（在 `SIGALRM` 处理程序内）利用这个不一致的状态。
   
   在我们的实验中，平均需要约 10,000 次尝试才能赢得这场竞争条件；即在每 600 秒（`LoginGraceTime`）接受 10 个连接（`MaxStartups`）的情况下，平均需要约 1 周时间才能获得远程 root shell。

- Second, "SSH-2.0-OpenSSH_4.2p1 Debian-7ubuntu3", from
  "ubuntu-6.06.1-server-i386.iso": this is the last Ubuntu version that
  is still vulnerable to CVE-2006-5051 ("Signal handler race condition
  in OpenSSH before 4.4").

  To remotely exploit this version, we interrupt a call to pam_start()
  with SIGALRM, leave one of PAM's structures in an inconsistent state,
  and exploit this inconsistent state during a call to pam_end(), inside
  the SIGALRM handler.

  In our experiments, it takes ~10,000 tries on average to win this race
  condition; i.e., with 10 connections (MaxStartups) accepted per 120
  seconds (LoginGraceTime), it takes ~1-2 days on average to obtain a
  remote root shell.
- **其次，"SSH-2.0-OpenSSH_4.2p1 Debian-7ubuntu3"，来自 "ubuntu-6.06.1-server-i386.iso"：** 这是最后一个仍然易受 CVE-2006-5051（"OpenSSH 4.4 之前的版本中信号处理程序竞争条件"）影响的 Ubuntu 版本。
  
  要远程利用这个版本，我们通过 `SIGALRM` 中断对 `pam_start()` 的调用，使其中一个 PAM 结构处于不一致的状态，然后在 `pam_end()` 的调用中（在 `SIGALRM` 处理程序内）利用这个不一致的状态。
  
  在我们的实验中，平均需要约 10,000 次尝试才能赢得这场竞争条件；即在每 120 秒（`LoginGraceTime`）接受 10 个连接（`MaxStartups`）的情况下，平均需要约 1-2 天时间才能获得远程 root shell。


- Finally, "SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u2", from
  "debian-12.5.0-i386-DVD-1.iso": this is the current Debian stable
  version, and it is vulnerable to the regression of CVE-2006-5051.

  To remotely exploit this version, we interrupt a call to malloc() with
  SIGALRM (inside sshd's public-key parsing code), leave the heap in an
  inconsistent state, and exploit this inconsistent state during another
  call to malloc(), inside the SIGALRM handler (more precisely, inside
  syslog()).

  In our experiments, it takes ~10,000 tries on average to win this race
  condition, so ~3-4 hours with 100 connections (MaxStartups) accepted
  per 120 seconds (LoginGraceTime). Ultimately, it takes ~6-8 hours on
  average to obtain a remote root shell, because we can only guess the
  glibc's address correctly half of the time (because of ASLR).
- **最后，"SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u2"，来自 "debian-12.5.0-i386-DVD-1.iso"：** 这是当前的 Debian 稳定版，且易受 CVE-2006-5051 回归漏洞的影响。
    
  要远程利用这个版本，我们通过 `SIGALRM` 中断对 `malloc()` 的调用（在 sshd 的公钥解析代码中），将堆留在不一致的状态，然后在另一次调用 `malloc()` 时（在 `SIGALRM` 处理程序内，准确地说是在 `syslog()` 内）利用这个不一致的状态。
    
  在我们的实验中，平均需要约 10,000 次尝试才能赢得这场竞争条件，因此在每 120 秒（`LoginGraceTime`）接受 100 个连接（`MaxStartups`）的情况下，平均需要 3-4 小时才能获得远程 root shell。最终，由于我们只能在一半的情况下正确猜测 glibc 的地址（由于 ASLR），因此平均需要 6-8 小时才能获得远程 root shell。
    

This research is still a work in progress:
- we have targeted virtual machines only, not bare-metal servers, on a
  mostly stable network link (~10ms packet jitter);
- we are convinced that various aspects of our exploits can be greatly
  improved;
- we have started to work on an amd64 exploit, which is much harder
  because of the stronger ASLR.
A few days after we started our work on amd64, we noticed the following
bug report (in OpenSSH's public Bugzilla), about a deadlock in sshd's
SIGALRM handler:
  https://bugzilla.mindrot.org/show_bug.cgi?id=3690
We therefore decided to contact OpenSSH's developers immediately (to let
them know that this deadlock is caused by an exploitable vulnerability),
we put our amd64 work on hold, and we started to write this advisory.
**这项研究仍在进行中：
- 我们目前仅针对虚拟机进行了研究，而未涉及裸机服务器，网络链接大多是稳定的（~10ms 的数据包抖动）；
- 我们确信，漏洞利用的各个方面仍有很大的改进空间；
- 我们已经开始开发针对 amd64 的漏洞利用，这更加困难，因为该架构具有更强的地址空间布局随机化（ASLR）。
在我们开始研究 amd64 的几天后，我们注意到 OpenSSH 的公共 Bugzilla 上有如下关于 sshd 的 `SIGALRM` 处理程序死锁的漏洞报告：
[https://bugzilla.mindrot.org/show_bug.cgi?id=3690](https://bugzilla.mindrot.org/show_bug.cgi?id=3690)
因此，我们决定立即联系 OpenSSH 的开发者（告知他们这个死锁是由可被利用的漏洞引起的），暂停了 amd64 的相关工作，并开始撰写这份安全公告。


# SSH-2.0-OpenSSH_3.4p1 Debian 1:3.4p1-1.woody.3 (Debian 3.0r6, from 2005)
## Theory
## Practice
## Timing


# SSH-2.0-OpenSSH_4.2p1 Debian-7ubuntu3 (Ubuntu 6.06.1, from 2006)

## Theory, take one
## Theory, take two
## Practice
## Timing


# SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u2 (Debian 12.5.0, from 2024)
## Theory
    Now you're ready, take the demons head on
        -- The Interrupters, "Be Gone"
 
The SIGALRM handler of this OpenSSH version does not call packet_close()
nor pam_end(); in fact it calls only one interesting function, syslog():
在该 OpenSSH 版本中，SIGALRM 信号的处理程序 `grace_alarm_handler()` 没有调用 `packet_close()` 或 `pam_end()`，仅调用了一个有趣的函数 `syslog()`：


``` C
/*
 * Signal handler for the alarm after the login grace period has expired.
 
 `grace_alarm_handler` 是一个信号处理函数，专用于处理登录宽限期（grace period）超时时触发的 `SIGALRM` 信号。它的主要功能是：
 1. 终止相关子进程。
 2. 清理资源并记录超时错误日志。
 3. 退出程序。
 */

/*ARGSUSED*/

static void

grace_alarm_handler(int sig)

{
   /*
   * 检查是否启用了 **特权分离** (`use_privsep`)，并确认 `pmonitor`（监视器进程对象）有效且其子进程 ID（`m_pid`）大于 0。
   * 如果满足条件，向监视器进程发送 `SIGALRM` 信号，通知它超时。
   */
    if (use_privsep && pmonitor != NULL && pmonitor->m_pid > 0)

        kill(pmonitor->m_pid, SIGALRM);

    /*

     * Try to kill any processes that we have spawned, E.g. authorized

     * keys command helpers.

     */

    if (getpgid(0) == getpid()) {

        ssh_signal(SIGTERM, SIG_IGN);

        kill(0, SIGTERM);

    }
    
    /* Log error and exit. */
    if (use_privsep && pmonitor != NULL && pmonitor->m_pid <= 0)
        cleanup_exit(255); /* don't log in privsep child */
    else {
        // `sigdie` 是一个日志记录和终止程序的函数，专门用于处理信号触发的紧急退出。
        // 三个参数分别是：格式化字符串，用于生成日志消息，表示客户端在登录超时时间内未完成身份验证；客户端的 IP 地址；客户端连接的端口号
        sigdie("Timeout before authentication for %s port %d",

            ssh_remote_ipaddr(the_active_state),

            ssh_remote_port(the_active_state));
    }

}
```


``` C
#define sigdie(...)     sshsigdie(__FILE__, __func__, __LINE__, 0, SYSLOG_LEVEL_ERROR, NULL, __VA_ARGS__)
```

``` C
void

sshsigdie(const char *file, const char *func, int line, int showfunc,
    LogLevel level, const char *suffix, const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    sshlogv(file, func, line, showfunc, SYSLOG_LEVEL_FATAL,
        suffix, fmt, args);
    va_end(args);
    _exit(1);
}
```

``` C
void

sshlogv(const char *file, const char *func, int line, int showfunc,

    LogLevel level, const char *suffix, const char *fmt, va_list args)

{

    char tag[128], fmt2[MSGBUFSIZ + 128];

    int forced = 0;

    const char *cp;

    size_t i;


    snprintf(tag, sizeof(tag), "%.48s:%.48s():%d (pid=%ld)",

        (cp = strrchr(file, '/')) == NULL ? file : cp + 1, func, line,

        (long)getpid());

    for (i = 0; i < nlog_verbose; i++) {

        if (match_pattern_list(tag, log_verbose[i], 0) == 1) {

            forced = 1;

            break;

        }

    }

  

    if (forced)

        snprintf(fmt2, sizeof(fmt2), "%s: %s", tag, fmt);

    else if (showfunc)

        snprintf(fmt2, sizeof(fmt2), "%s: %s", func, fmt);

    else

        strlcpy(fmt2, fmt, sizeof(fmt2));

    do_log(level, forced, suffix, fmt2, args);

}
```


``` C
337 do_log(LogLevel level, int force, const char *suffix, const char *fmt,
338     va_list args)
339 {
...
419                 syslog(pri, "%.500s", fmtbuf);
```

Our two key questions, then, are: Does the syslog() of this Debian's
glibc (2.36) call async-signal-unsafe functions such as malloc() and
free()? And if yes, does this glibc still take a mandatory lock when
entering the functions of the malloc family?

- Luckily for us attackers, the answer to our first question is yes; if,
  and only if, the syslog() inside the SIGALRM handler is the very first
  call to syslog(), then __localtime64_r() (which is called by syslog())
  calls malloc(304) to allocate a FILE structure (at line 166) and calls
  malloc(4096) to allocate an internal read buffer (at line 186):

我们的两个关键问题是：这个 Debian 系统的 glibc（2.36）中的 syslog() 是否调用了如 malloc() 和 free() 这样的异步信号不安全函数？如果是，这个 glibc 在进入 malloc 家族的函数时，是否仍然会强制加锁？
- 幸运的是，对于我们这些攻击者，第一个问题的答案是肯定的；如果且仅如果在 SIGALRM 处理程序中的 syslog() 是第一次调用 syslog()，那么 __localtime64_r()（由 syslog() 调用）会调用 malloc(304) 来分配一个 FILE 结构体（在第 166 行），并调用 malloc(4096) 来分配一个内部读取缓冲区（在第 186 行）：
![[Pasted image 20241220095222.png]]








  Note: because we do not control anything about these malloc()ations
  (not their order, not their sizes, not their contents), we took the
  "rce" at line 166 as a much-needed good omen.

- And luckily for us, the answer to our second question is no; since
  October 2017, the glibc's malloc functions do not take any lock
  anymore, when single-threaded (like sshd):

  https://sourceware.org/git?p=glibc.git;a=commit;h=a15d53e2de4c7d83bda251469d92a3c7b49a90db
  https://sourceware.org/git?p=glibc.git;a=commit;h=3f6bb8a32e5f5efd78ac08c41e623651cc242a89
  https://sourceware.org/git?p=glibc.git;a=commit;h=905a7725e9157ea522d8ab97b4c8b96aeb23df54

Moreover, this Debian version suffers from the ASLR weakness described
in the following great blog posts (by Justin Miller and Mathias Krause,
respectively):

  https://zolutal.github.io/aslrnt/
  https://grsecurity.net/toolchain_necromancy_past_mistakes_haunting_aslr

Concretely, in the case of sshd on i386, every memory mapping is
randomized normally (sshd's PIE, the heap, most libraries, the stack),
but the glibc itself is always mapped either at address 0xb7200000 or at
address 0xb7400000; in other words, we can correctly guess the glibc's
address half of the time (a small price to pay for defeating ASLR). In
our exploit we assume that the glibc is mapped at address 0xb7400000,
because it is slightly more common than 0xb7200000.

Our next question is: which code paths inside the glibc's malloc
functions, if interrupted by SIGALRM at the right time, leave the heap
in an inconsistent state, exploitable during one of the malloc() calls
inside the SIGALRM handler?

We found several interesting (and surprising!) code paths, but the one
we chose involves only relative sizes, not absolute addresses (unlike
various code paths inside unlink_chunk(), for example); this difference
might prove crucial for a future amd64 exploit. This code path, inside
malloc(), splits a large free chunk (victim) into two smaller chunks;
the first chunk is returned to malloc()'s caller (at line 4345) and the
second chunk (remainder) is linked into an unsorted list of free chunks
(at lines 4324-4327):

------------------------------------------------------------------------
1449 #define set_head(p, s)       ((p)->mchunk_size = (s))
------------------------------------------------------------------------
3765 _int_malloc (mstate av, size_t bytes)
3766 {
....
3798   nb = checked_request2size (bytes);
....
4295               size = chunksize (victim);
....
4300               remainder_size = size - nb;
....
4316                   remainder = chunk_at_offset (victim, nb);
....
4320                   bck = unsorted_chunks (av);
4321                   fwd = bck->fd;
....
4324                   remainder->bk = bck;
4325                   remainder->fd = fwd;
4326                   bck->fd = remainder;
4327                   fwd->bk = remainder;
....
4337                   set_head (victim, nb | PREV_INUSE |
4338                             (av != &main_arena ? NON_MAIN_ARENA : 0));
4339                   set_head (remainder, remainder_size | PREV_INUSE);
....
4343               void *p = chunk2mem (victim);
....
4345               return p;
------------------------------------------------------------------------

- If this code path is interrupted by SIGALRM *after* line 4327 but
  *before* line 4339, then the remainder chunk of this split is already
  linked into the unsorted list of free chunks (lines 4324-4327), but
  its size field (mchunk_size) is not yet initialized (line 4339).

- If we are able to control its size field (through leftovers from
  previous heap allocations), then we can make this remainder chunk
  larger and overlap with other heap chunks, and therefore corrupt heap
  memory when this enlarged, overlapping remainder chunk is eventually
  malloc()ated and written to (inside the SIGALRM handler).

Our last question, then, is: given that we do not control anything about
the malloc() calls inside the SIGALRM handler, what can we overwrite in
the heap to achieve arbitrary code execution before sshd calls _exit()
(in sshsigdie())?

Because __tzfile_read() (inside the SIGALRM handler) malloc()ates a FILE
structure in the heap (at line 166 above), and because FILE structures
have a long history of abuse for arbitrary code execution, we decided to
aim our heap corruption at this FILE structure. This is, however, easier
said than done: our heap corruption is very limited, and FILE structures
have been significantly hardened over the years (by IO_validate_vtable()
and PTR_DEMANGLE(), for example).

Eventually, we devised the following technique (which seems to be
specific to the i386 glibc -- the amd64 glibc does not seem to use
_vtable_offset at all):

- with our limited heap corruption, we overwrite the _vtable_offset
  field (a single signed char) of __tzfile_read()'s FILE structure;

- the glibc's libio functions will therefore look for this FILE
  structure's vtable pointer (a pointer to an array of function
  pointers) at a non-zero offset (our overwritten _vtable_offset),
  instead of the default zero offset;

- we (attackers) can easily control this fake vtable pointer (through
  leftovers from previous heap allocations), because the FILE structure
  around this offset is not explicitly initialized by fopen();

- to pass the glibc's security checks, our fake vtable pointer must
  point somewhere into the __libc_IO_vtables section: we decided to
  point it to the vtable for wide-character streams, _IO_wfile_jumps
  (i.e., to 0xb761b740, since we assume that the glibc is mapped at
  address 0xb7400000);

- as a result, __fread_unlocked() (at line 186 above) calls
  _IO_wfile_underflow() (instead of _IO_file_underflow()), which calls a
  function pointer (__fct) that basically comes from a structure whose
  pointer (_codecvt) is yet another field of the FILE structure;

- we (attackers) can easily control this _codecvt pointer (through
  leftovers from previous heap allocations, because this field of the
  FILE structure is not explicitly initialized by fopen()), which also
  allows us to control the __fct function pointer.

In summary, by overwriting a single byte (_vtable_offset) of the FILE
structure malloc()ated by fopen(), we can call our own __fct function
pointer and execute arbitrary code during __fread_unlocked().




## Practice
## Timing


# Towards an amd64 exploit
# Patches and mitigation
# Acknowledgments
# Timeline



